---
layout: post
title:  TwoPart
date:   2018-11-21 00:00:00 +0800
categories: document
tag: 测试
---

* content
{:toc}


## 震惊，我居然忘记了二分

~~这件事真恐怖~~

好了我知道我很菜

二分能解决的问题很简单，仅仅三种

1. **存在单调性的查找**
2. **最大最小值（使……最大的最小值）**
3. **最小最大值（同理）**

### 二分的结构

-----------------

不说了直接代码

```c++
while(l<=r)//在可能的范围内
{
    if(check()) update(ans),change(l);//如果符合题意，更新答案并且优化子集搜索区间
    else change(r);//如果不符合题意，弱化子集搜索区间
}
```

<pre class="brush: ruby">
while(l<=r)//在可能的范围内
{
    if(check()) update(ans),change(l);//如果符合题意，更新答案并且优化子集搜索区间
    else change(r);//如果不符合题意，弱化子集搜索区间
}
</pre>

{% highlight ruby %}
    while(l<=r)//在可能的范围内
{
    if(check()) update(ans),change(l);//如果符合题意，更新答案并且优化子集搜索区间
    else change(r);//如果不符合题意，弱化子集搜索区间
}
{% endhighlight %}

~~好像说得不清楚~~

子集即为答案可能存在的集合，优化即为向更优的方向改变答案，弱化即为由于不符合题意而被迫寻找更次的答案（~~我知道我语文不好~~）

**二分的实质即为不断缩小答案或最优解所在集合最后确定解或最优解**

### check函数的写法

___

又是一堆代码

```c++
bool check(int x)//传可能的答案进来模拟，即假设答案为x
{
    ...//由题意进行，检查实际操作时是否与题意有冲突
    if(flag==0) return 0;//不符合题意，这个可以加在上一个过程中，可以节约时间
    return 1;//符合题意
}
```

在返回值的时候，请注意与下方答案更新项相匹配

### 对于二分最容易错的符号问题

---------

~~其实跳石头我都不会，这真是令人窒息的操作~~

但实际上很简单

#### 1.对于while后面是l<=r还是l<r的问题

​	实际上就是l=r时是否进行的问题，显然还是要进行的，因为此时答案可能存在的区间还有一个元素，所以一定是l<=r

#### 2.对于下方l,r是否加一减一的操作

​	实际上就是答案子集区间是否可能存在边界即为答案的可能性。对于符合题意时，由于在r和l中一定有更新答案这一步，所以更新的答案一定是符合题意的，更优的答案自然不会包括已经更新的答案；而在不符合题意的时候，答案更优解就更不可能为不符合题意的解了，即同样不会包括不合法的解。

**总之，l<=r，l=mid+1，r=mid-1**

